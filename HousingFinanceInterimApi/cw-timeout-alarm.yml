generateAlarms: |
  ${((lambdas) => {
    const resources = {};
    for (const { functionName } of lambdas) {
      const logicalId = functionName.charAt(0).toUpperCase() + functionName.slice(1);
      resources[`${logicalId}TimeoutMetricFilter`] = {
        Type: "AWS::Logs::MetricFilter",
        Properties: {
          LogGroupName: `/aws/lambda/${functionName}-${self:provider.stage}`,
          FilterPattern: "Task timed out after",
          MetricTransformations: [
            {
              MetricValue: "1",
              MetricNamespace: "Lambda/Timeouts",
              MetricName: `${functionName}-TimeoutCount`,
              DefaultValue: 0
            }
          ]
        }
      };
      resources[`${logicalId}TimeoutAlarm`] = {
        Type: "AWS::CloudWatch::Alarm",
        Properties: {
          AlarmName: `${functionName}-${self:provider.stage}-timeout-alarm`,
          AlarmDescription: `Timeout alarm for ${functionName}`,
          MetricName: `${functionName}-TimeoutCount`,
          Namespace: "Lambda/Timeouts",
          Statistic: "Sum",
          Period: 900,
          EvaluationPeriods: 1,
          Threshold: 0,
          ComparisonOperator: "GreaterThanThreshold",
          TreatMissingData: "notBreaching",
          ActionsEnabled: true,
          AlarmActions: [ { Ref: "LambdaTimeoutAlarmTopic" } ]
        }
      };
    }
    return resources;
  })(params)}
